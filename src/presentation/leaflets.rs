// Released under MIT License.
// Copyright (c) 2024-2026 Ladislav Bartos

//! Structures and methods for storing and accessing leaflet assignment data.

use std::{
    fs::File,
    io::{BufWriter, Write},
    path::Path,
};

use getset::Getters;
use hashbrown::HashMap;
use indexmap::IndexMap;

use crate::{
    errors::WriteError,
    input::{Analysis, Frequency},
    prelude::AAOrderResults,
    presentation::{OutputFormat, Presenter, YamlPresenter},
    Leaflet, GORDER_VERSION, PANIC_MESSAGE,
};

/// Data for storing and presenting the leaflet assignment data.
#[derive(Debug, Clone, Getters)]
pub struct LeafletsData {
    /// Indices of trajectory frames for which leaflet assignment was performed with the first analyzed frame having the index 1.
    #[getset(get = "pub")]
    frames: Vec<usize>,
    /// Leaflet assignment for each lipid and each analyzed frame.
    assignment: IndexMap<String, Vec<Vec<Leaflet>>>,
}

impl LeafletsData {
    /// Initialize the LeafletsData structure.
    /// - `n_analyzed_frames` is the total number of analyzed frames
    pub(super) fn new(analysis: &Analysis, n_analyzed_frames: usize) -> Self {
        let assignment_frequency = analysis
            .leaflets()
            .as_ref()
            .expect(PANIC_MESSAGE)
            .get_frequency();

        // determine the number of frames that were assigned
        let n_assigned_frames = match assignment_frequency {
            Frequency::Once => 1,
            Frequency::Every(n) => n_analyzed_frames.div_ceil(n.get()),
        };

        // determine the step between assigned frames
        let step_increment = match assignment_frequency {
            Frequency::Once => analysis.step(), // irrelevant
            Frequency::Every(n) => n.get() * analysis.step(),
        };

        // generate the assigned frame indices
        let frames: Vec<usize> = std::iter::successors(Some(1), |prev| Some(prev + step_increment))
            .take(n_assigned_frames)
            .collect();

        Self {
            frames,
            assignment: IndexMap::new(),
        }
    }

    /// Get leaflet assignment data for a lipid type `name`.
    /// Returns `None` if no data for the lipid type could be found.
    #[inline]
    pub fn get_molecule(&self, name: &str) -> Option<&Vec<Vec<Leaflet>>> {
        self.assignment.get(name)
    }

    /// Export the data into an output file.
    pub fn export(
        &self,
        filename: &impl AsRef<Path>,
        trajectories: &[String],
        overwrite: bool,
    ) -> Result<(), WriteError> {
        // the type of presenter does not matter in this case
        let file_status = YamlPresenter::<AAOrderResults>::try_backup(filename, overwrite)?;
        let file = File::create(filename.as_ref())
            .map_err(|_| WriteError::CouldNotCreateFile(Box::from(filename.as_ref())))?;
        let mut writer = BufWriter::new(file);

        self.write_header(&mut writer, trajectories)?;
        self.write_data(&mut writer)?;

        file_status.info_custom(
            OutputFormat::YAML,
            filename.as_ref().to_str().expect(PANIC_MESSAGE),
            "leaflet classification data",
        );

        Ok(())
    }

    /// Write the header for the leaflet classification file.
    fn write_header(
        &self,
        writer: &mut impl Write,
        trajectory: &[String],
    ) -> Result<(), WriteError> {
        if trajectory.len() == 1 {
            write_result!(
                writer,
                "# Leaflet assignment file generated by 'gorder v{}' using a trajectory file '{}'.\n",
                GORDER_VERSION,
                trajectory.first().expect(PANIC_MESSAGE)
            );
        } else {
            write_result!(
                writer,
                "# Leaflet assignment file generated by 'gorder v{}' using trajectory files '{}'.\n",
                GORDER_VERSION,
                trajectory.join(" ")
            );
        }

        Ok(())
    }

    /// Write the leaflet classification data into the output.
    fn write_data(&self, writer: &mut impl Write) -> Result<(), WriteError> {
        for (lipid, assign) in self.assignment.iter() {
            write_result!(writer, "{}:\n", lipid);
            for (frame_data, frame_index) in assign.iter().zip(self.frames.iter()) {
                write_result!(writer, "# Frame index {}\n", frame_index);
                write_result!(
                    writer,
                    "  - [{}]\n",
                    frame_data
                        .iter()
                        .map(|leaflet| match leaflet {
                            Leaflet::Upper => "1",
                            Leaflet::Lower => "0",
                        })
                        .collect::<Vec<&str>>()
                        .join(",")
                );
            }
        }

        Ok(())
    }

    /// Add data obtained for a single lipid type into the structure.
    pub(super) fn add_molecule_type(
        &mut self,
        name: &str,
        mut assignment: HashMap<usize, Vec<Leaflet>>,
    ) {
        let molecule_assignment: Vec<_> = self.frames.iter()
            .map(|&frame| {
                // here, we number frames starting from 1, but internally we use 0-based indexing
                assignment.remove(&(frame - 1)).unwrap_or_else(|| {
                    panic!(
                        "FATAL GORDER ERROR | LeafletsData::add_molecule_type | Frame index {} is not present in the stored leaflet assignment data. {}",
                        frame - 1, PANIC_MESSAGE
                    )
                })
            })
            .collect();

        self.assignment.insert(name.to_owned(), molecule_assignment);

        // defensive check that we have collected all the frames for which assignment is known
        assert!(assignment.is_empty(), "FATAL GORDER ERROR | LeafletsData::add_molecule_type | All the necessary frames were extracted: the assignment storage should be empty. {}", PANIC_MESSAGE);
    }

    /// Returns `true` if no leaflet assignment data have been collected.
    pub(super) fn is_empty(&self) -> bool {
        self.assignment.is_empty()
    }
}
